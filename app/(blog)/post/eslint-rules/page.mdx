https://eslint.org/docs/latest/rules/no-async-promise-executor

The executor function can also be an async function. However, this is usually a
mistake. If an async executor function throws an error, the error will be lost
and won’t cause the newly-constructed Promise to reject.

https://eslint.org/docs/latest/rules/no-await-in-loop

In many cases the iterations of a loop are not actually independent of
each-other. For example, the output of one iteration might be used as the input
to another. Or, loops may be used to retry asynchronous operations that were
unsuccessful. Or, loops may be used to prevent your code from sending an
excessive amount of requests in parallel.

https://eslint.org/docs/latest/rules/no-compare-neg-zero

```js
console.log(0 === -0);
console.log(Object.is(0, -0));
```

https://eslint.org/docs/latest/rules/no-constant-binary-expression

```js
console.log(1 + null ?? 2);
console.log([] === []);
```

https://eslint.org/docs/latest/rules/no-misleading-character-class

Unicode includes characters which are made by multiple code points. RegExp
character class syntax (/[abc]/) cannot handle characters which are made by
multiple code points as a character; those characters will be dissolved to each
code point. For example, ❇️ is made by ❇ (U+2747) and VARIATION SELECTOR-16
(U+FE0F). If this character is in a RegExp character class, it will match either
❇ (U+2747) or VARIATION SELECTOR-16 (U+FE0F) rather than ❇️.

https://eslint.org/docs/latest/rules/no-prototype-builtins

Additionally, objects can have properties that shadow the builtins on
Object.prototype, potentially causing unintended behavior or denial-of-service
security vulnerabilities. For example, it would be unsafe for a webserver to
parse JSON input from a client and call hasOwnProperty directly on the resulting
object, because a malicious client could send a JSON value like
`{"hasOwnProperty": 1}` and cause the server to crash.

https://eslint.org/docs/latest/rules/no-self-compare

The only time you would compare a variable against itself is when you are
testing for NaN. However, it is far more appropriate to use typeof x ===
'number' && isNaN(x) or the Number.isNaN ES2015 function for that use case
rather than leaving the reader of the code to determine the intent of self
comparison.

```js
let f = (x) => x === x;
let g = (x) => typeof x === 'number' && isNaN(x);
let h = (x) => Number.isNaN(x);
```

Instance fields of a subclass are only added to the instance after super().

https://eslint.org/docs/latest/rules/no-useless-backreference

Regex 잘 모름 ㅎㅎ;

https://eslint.org/docs/latest/rules/require-atomic-updates

```js
let total = 0;

let identity = async (x) => x;

let addVal = async (x) => {
  total += await identity(x);
};

Promise.all([addVal(1), addVal(2), addVal(3)]).then(() => {
  log(total);
});
```

```js
async function foo(obj) {
  if (!obj.done) {
    obj.something = await getSomething();
  }
}
```

https://eslint.org/docs/latest/rules/func-style

The primary difference between function declarations and function expressions is
that declarations are hoisted to the top of the scope in which they are defined,
which allows you to write code that uses the function before its declaration.

https://eslint.org/docs/latest/rules/no-array-constructor

Use of the Array constructor to construct a new array is generally discouraged
in favor of array literal notation because of the single-argument pitfall and
because the Array global may be redefined. The exception is when the Array
constructor is used to intentionally create sparse arrays of a specified size by
giving the constructor a single numeric argument.

https://eslint.org/docs/latest/rules/no-implicit-coercion

이런 것도 있네..

https://eslint.org/docs/latest/rules/no-invalid-this

Under the strict mode, this keywords outside of classes or class-like objects
might be undefined and raise a TypeError.

https://eslint.org/docs/latest/rules/no-loop-func

```js
let foo = 0;
for (let i = 0; i < 10; ++i) {
  //Bad, `foo` is not in the loop-block's scope and `foo` is modified in/after the loop
  setTimeout(() => console.log(foo));
  foo += 1;
}
```

```js
for (let i = 0; i < 10; ++i) {
  //Bad, `foo` is not in the loop-block's scope and `foo` is modified in/after the loop
  setTimeout(() => console.log(foo));
}
foo = 100;
```

https://eslint.org/docs/latest/rules/no-new-wrappers

```js
var booleanObject = new Boolean(false);
if (booleanObject) {
  // all objects are truthy!
  console.log('This executes');
}
```

https://eslint.org/docs/latest/rules/no-param-reassign

Strict mode code doesn’t sync indices of the arguments object with each
parameter binding. Therefore, this rule is not necessary to protect against
arguments object mutation in ESM modules or other strict mode functions.

https://johnresig.com/blog/objectgetprototypeof/

특정 문법, 프로퍼티, 전역 변수 등에 대한 접근도 막을 수 있습니다:

https://eslint.org/docs/latest/rules/no-sequences

https://eslint.org/docs/latest/rules/no-undef-init

```js
for (i = 0; i < 4; i++) {
  // ✍️ var x;로 바꿔보세요.
  var x = undefined;
  console.log(x);
  x = i;
}
```

https://eslint.org/docs/latest/rules/object-shorthand

```js
class A {
  foo() {}
  bar = function () {};
}

let a = new A();
console.log(Object.hasOwn(a, 'foo'));
console.log(Object.hasOwn(a, 'bar'));
```

https://eslint.org/docs/latest/rules/radix

```js
console.log(parseInt('0x71'));
```

https://github.com/eslint/eslint/issues/11542
